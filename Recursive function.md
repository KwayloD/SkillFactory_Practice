### **Вычислить порядковый номер числа Фибоначчи.**

```python
def rec_fibb(n):
   if n == 1:
       return 1
   if n == 2:
      return 1
   return rec_fibb(n - 1) + rec_fibb(n - 2)

rec_fibb(10)  # 55
```

Когда мы вызываем функцию `rec_fibb(10)`, происходит следующее:

1. Проверяется, равно ли `n` (которое в этом случае равно *10*) *1* или *2*. Условие не выполняется, поэтому переходим к следующему шагу.
2. Затем функция рекурсивно вызывает себя дважды, передавая в качестве аргументов `n-1` и `n-2`. То есть `rec_fibb(9)` и `rec_fibb(8)`.
3. Переходим к вызову `rec_fibb(9)`:
   - Снова проверяется, равно ли `n` (которое теперь равно 9) *1* или *2*. Условие не выполняется, поэтому продолжаем.
   - Функция вызывается рекурсивно, например, `rec_fibb(9 - 1)` = `rec_fibb(8)`.
4. Переходим к вызову `rec_fibb(8)`:
   - Проверка условия `n == 1` или `n == 2` не выполняется.
   - Функция вызывается рекурсивно с аргументами `n-1` и `n-2`, например, `rec_fibb(8 - 1)` = `rec_fibb(7)`.
   - То же самое происходит с вызовом `rec_fibb(7)`, `rec_fibb(6)`, и так далее, пока мы не достигнем базового случая `n == 1` или `n == 2`.
5. Когда мы достигаем базовых случаев, функция начинает возвращаться обратно.
   - `rec_fibb(2)` возвращает *1*.
   - `rec_fibb(3)` возвращает `rec_fibb(2)` + `rec_fibb(1)` = *1 + 1 = 2*.
   - `rec_fibb(4)` возвращает `rec_fibb(3)` + `rec_fibb(2)` = *2 + 1 = 3*.
   - `rec_fibb(5)` возвращает `rec_fibb(4)` + `rec_fibb(3)` = *3 + 2 = 5*.
   - И так далее, пока мы не достигнем `rec_fibb(10)`, который будет равен `rec_fibb(9)` + `rec_fibb(8)` = *34 + 21 = 55*.


*Таким образом, на каждом шаге функция вызывает саму себя для нахождения двух предыдущих чисел Фибоначчи, после чего суммирует их, чтобы найти следующее число. Когда мы достигаем базового случая, функция начинает возвращаться и вычисляет конечное значение.*

___

### **Дано натуральное число N. Вычислите сумму его цифр.**
```python
def sum_digit(n):
   if n < 10:
       return n
   else:
       return n % 10 + sum_digit(n // 10)

sum_digit(123)  # 6
```

Приведенный код представляет функцию с именем `sum_digit`, которая принимает целое число `n` в качестве аргумента. 

Функция `sum_digit` рекурсивно вычисляет сумму цифр числа `n`. 

Сначала проверяется базовый случай: если число `n` меньше 10 (то есть состоит из одной цифры), то оно сразу возвращается, так как сумма цифр равна самому числу.

В противном случае, выполняется ветка `else`. Вычисляется остаток от деления числа `n` на 10 при помощи оператора `%`, затем к этому остатку прибавляется рекурсивный вызов функции `sum_digit`, в которую передается целая часть от деления `n` на 10 при помощи оператора `//`. Это позволяет получить сумму оставшихся цифр числа `n`. Наконец, полученная сумма остатка и суммы остальных цифр возвращается из функции.

В данном конкретном примере функция `sum_digit` вызывается с аргументом 123. Рекурсивно будет вычислено следующее:

- sum_digit(123) = 3 + sum_digit(12)
- sum_digit(12) = 2 + sum_digit(1)
- sum_digit(1) = 1

*Итого, `sum_digit(123)` вернет результат **6**, так как сумма всех цифр числа **123** равна **1 + 2 + 3 = 6**.*
